macro var@@dlist
{
  local k
}
macro var@@rlist
{
  local k
}
macro var@@flist                        mode
{
  if ( var@@functions@@ctr + 1 )
    rndList                             var@@functions
  end if
}
macro var@@type                         type,     ddef,     rdef,     size,     vartype
{
  var@@#type#_type                      =                                       vartype
  ;var@@d_#type#_ptr                     =                                       ( var@@d_#type#s )
  newList                               var@@d_#type#_value
  var@@d_#type#_count                   =                                       ( null )
  var@@r_#type#_ptr                     =                                       ( var@@r_#type#s )
  var@@r_#type#_count                   =                                       ( null )
  match any0, ddef
  \{
    macro var@@dlist
    \\{
      var@@dlist
      if ( var@@d_#type#_value@@ctr + 1 )
        __pad__                         size
        var@@d_#type#s:
          rndList                       var@@d_#type#_value
      else
        var@@d_#type#s:
      end if
      var@@d_#type#_count@final         =                                       ( var@@d_#type#_count )
    \\}
  \}
  match any0, rdef
  \{
    macro var@@rlist
    \\{
      var@@rlist
      if ( var@@r_#type#_count )
        rb                              ((( $ + size - 1 ) and ( 0 - size )) - $ )
        var@@r_#type#s:
          rdef                          var@@r_#type#_count
      else
        var@@r_#type#s:
      end if
      var@@r_#type#_count@final         =                                       ( var@@r_#type#_count )
    \\}
  \}
  macro type [ operant ]
  \{
    \common
      \local done, buffer
    \forward
      done                              equ
      match var==val, operant
      \\{
        if ( defined var\\#@@type )
          display '[asm:var:', `type, '] function or variable »', \\`var, '« already defined!', 10
          err
        else
          ;display 'add »', \\`var, '«', 10
        end if
        done                            equ                                     true
        addList                         var@@d_#type#_value,                    < buffer ddef val >
        var\\#@@type                    equ                                     var@@#type#_type
        var\\#@@size                    =                                       size
        var\\#@@value                   =                                       buffer
        var@@d_#type#_count             =                                       ( var@@d_#type#_count + 1 )
      \\}
      match , done
      \\{
        if ( defined operant\\#@@type )
          display '[asm:var:', `type, '] function or variable »', \\`operant, '« already defined!', 10
          err
        else
          display 'add »', \\`operant, '«', 10
        end if
        operant\#@@type                 equ                                     var@@#type#_type
        operant\#@@size                 =                                       size
        operant\#@@value                =                                       var@@r_#type#_ptr
        var@@r_#type#_ptr               =                                       ( var@@r_#type#_ptr + size )
        var@@r_#type#_count             =                                       ( var@@r_#type#_count + 1 )
      \\}
  \}
}
done                                    equ
match =amd64, __machine__
{
  var@@type                             pointer,  dq,       rq,       __qword__,          op@@tPointer
  done                                  equ                                     true
}
match =x86protected, __machine__
{
  var@@type                             pointer,  dd,       rd,       __dword__,          op@@tPointer
  done                                  equ                                     true
}
match =x86real, __machine__
{
  var@@type                             pointer,  dw,       rw,       __word__,           op@@tPointer
  done                                  equ                                     true
}
match , done
{
  display '[asm:op] unknown pointer-size!', 10
  err
}
macro do@@init
{
  local loooop
  if ( defined do@@init )
    do@@init
  end if
  if ( var@@d_pointer_count@final = null )
  else
    lea                                 rax,                                    [ __init__ ]
    lea                                 rsi,                                    [ var@@d_pointers ]
    mov                                 rdx,                                    var@@d_pointer_count@final
    loooop:
    ;{
      add                               qword [ rsi + __qword__ * ( rdx - 1 )], rax
      dec                               rdx
      jnz                               loooop
    ;}
  end if
}

var@@type                               qword,    dq,       rq,       __qword__,          op@@tVariable
var@@type                               dword,    dd,       rd,       __dword__,          op@@tVariable
var@@type                               word,     dw,       rw,       __word__,           op@@tVariable
var@@type                               byte,     db,       rb,       __byte__,           op@@tVariable

macro var@@dlist
{
  op@@stroff:
    rndList                             op@@strlst
;  var@@d_strings:
;    rndList                             var@@d_string_value
  var@@dlist
}
newList op@@strlst
macro string operant, [ rest ]
{
  local done, size, buffer
  done                                  equ
  match var==val, operant
  \{
    if ( defined var\#@@type )
      display '[asm:var:string] function or variable »', \`var, '« already defined!', 10
      err
    else
      ;display 'add »', \`var, '«', 10
    end if
    done                                equ                                     true
    virtual                             at null
      db                                val
      match any, rest
      \\{
        db                              rest
      \\}
      size                              =                                       ( $ )
    end virtual
    match , rest
    \\{
      addList                           op@@strlst,                             < buffer db ( size and 0xff ), (( size shr 8 ) and 0xff ), val >
    \\}
    match any, rest
    \\{
      addList                           op@@strlst,                             < buffer db ( size and 0xff ), (( size shr 8 ) and 0xff ), val, rest >
    \\}
    pointer var\#@@pointer = ( buffer + 2 - __init__ )
    var\#@@type                         equ                                     op@@tBuffer
    var\#@@size                         =                                       size
    var\#@@value                        =                                       var\#@@pointer@@value

    displayValue '*string = 0x', ( buffer + 2 - __init__ + __init__ * 1 )
    displayValue 'string  = 0x', var\#@@pointer@@value
 ;   var@@d_pointer_ptr                  =                                       ( var@@d_pointer_ptr + __qword__ )
    ;var@@d_pointer_ptr                  =                                       ( var@@d_pointer_ptr + __dword__ )
;    var@@d_string_ptr                   =                                       ( var@@d_string_ptr + 2 + size )
  \}
  match , done
  \{
    if ( defined operant\#@@type )
      display '[asm:var:string] function or variable »', \`operant, '« already defined!', 10
      err
    else
      display 'add »', \`operant, '«', 10
    end if
    pointer var\#@@pointer
;    qword operant\#@@pointer
  \}
}

__isGlobal__                            equ                                     =
macro return                            value
{
  match , __isGlobal__
  \{
    ret
  \}
  match ==, __isGlobal__
  \{
    display '[asm:function] could not return outside a function!', 10
    err
  \}
}
newList var@@functions
macro function                          name,                                   argumente
{
  if ( defined name#@@type )
    display '[asm:var:function] function or variable »', \`name, '« already defined!', 10
    err
  else
    display 'function ', `name, '()', 10
  end if
  local size, __content__, __function__, __address__
  macro __function__
  \{
    __pad__                             16,                                     1
;    dq                                  __address__
;    dq                                  size
    __address__:
      __isGlobal__                      equ
      __stackframe__                    =                                       null
      __content__
      displayValue 'stackframesize 0x', __stackframe__
      __isGlobal__                      equ                                     =
    size                                =                                       ( $ - __address__ )
  \}
  addList                               var@@functions,                         < __function__ >
  name#@@type                           equ                                     op@@tFunction
  name#@@value                          =                                       ( __address__ )
  name#@@size                           =                                       size
  displayValue 'funtion()     = @0x', name#@@value
  displayValue 'funtion.size  =  0x', name#@@size
  macro name                            argumente
  \{
    local __item__, __count__, __mode__, register
    match any, argumente
    \\{
      ;display '[asm:function] parse arguments....', 10
      __count__                         =                                       null
      irp __item__, argumente
      \\\{
        __mode__                        equ
        match register=: value, __item__
        \\\\{
          __mode__                      equ                                     done
          mov                           register,                               value
        \\\\}
        match , __mode__
        \\\\{
          if      ( __count__ = 0 )
            mov                         lib0arg\\\#,                            __item__
          else if ( __count__ = 1 )
            mov                         lib1arg\#,                              __item__
          else if ( __count__ = 2 )
            mov                         lib2arg\#,                              __item__
          else if ( __count__ = 3 )
            mov                         lib3arg\#,                              __item__
          else if ( __count__ = 4 )
            mov                         lib4arg\#,                              __item__
          else if ( __count__ = 5 )
            mov                         lib5arg\#,                              __item__
          else
            display '[asm:function] cannot handle so many arguments yet! :(', 10
            err
          end if
          __count__                     =                                       ( __count__ + 1 )
        \\\\}
      \\\}
    \\}
    call                                __address__
  \}
  macro __content__
}

func                                    fix                                     function
