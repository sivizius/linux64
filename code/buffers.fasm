;:*next_page -+ +----------------------------------------> next_page
;:            | | +-------------------------------------+
;:            | | | +------------------------+          |
;:            ↓_|_|_| ____ ___ ____ ___ ____ ↓________  ↓_...
;:            | meta | b0 | v | b1 | v | b2 | free    | |
;:            | 40 b |    < strucBuffer >   |         | |
;:            |______|____|___|____|___|____|_________| |_...
;:            ↑       ↑__↑ ↑_↑ ↑__↑ ↑_↑ ↑__↑ ↑_______↑↑
;:            |        |    |   |    |   |   |        |
;:            |        +----¦---+----¦---+   |        |
;:            |        |    +-+------+       |        |
;:            |        |      |              |        |
;:            |        used   spam           free     |
;:            |_______________________________________|
;:             |
;:             size
;
;:*buffer -+------------------+
;:         | normal           | bigfoo
;:         ↓______ _________  ↓________ ______ ___________ ___________
;:         | size | content | | 0x8000 | page | used_size | page_size |
;:         | 2 b  | size b  | | 2 b    | 8 b  | 4 b       | 4 b       |
;:         |______|_________| |________|______|___________|___________|
;:                                      |
;:                                      ↓________________________________
;:                                      | content                        |
;:                                      | page_size b                    |
;:                                      |________________________________|
;@buffers.resv -> strucBuffersHeap
;{
;: 0x00 .list                           aq -> strucBuffersPage                  -> first *page/null
;: 0x08 .full                           ad                                      sum full_size
;: 0x0c .used                           ad                                      sum used_size
;: 0x10 .meta                           ad                                      sum meta_size
;: 0x14 .spam                           ad                                      sum spam_size
;: 0x18 .free                           ad                                      sum free_size
;: 0x1c .count                          ad                                      count objects
;:      .lastPage                       aq -> strucBuffersPage                  last used *page
;:      .last                           aq -> strucBuffers                      last used *buffer
;}
;*page -> strucBuffersPage
;{
;: 0x00 .next                           cq -> strucBuffersPage                  *next_page -> ... -> NULL
;: 0x08 .stop                           cq -> void                              ( *page + page_size )
;: 0x10 .here                           dq -> strucBuffers                      *new_buffer in { [ *page, *page + page_size - 2 ], NULL }
;: 0x18 .last                           dq -> strucBuffers                      *last
;: 0x20 .full                           cw                                      page_size = ( meta_size + used_size + spam_size + free_size )
;: 0x22 .free                           dw                                      free_size
;: 0x24 .used                           dw                                      used_size
;: 0x26 .spam                           dw                                      spam_size
;: 0x28 .                               db[ page_size - meta_size ]             content -> { buffer0, ..., bufferN } -> strucItem
;}
;*buffer -> strucBuffers
;{
;: 0x00 .size                           dw                                      content_size in [0x0000, 0xffff]
;: 0x02 .                               db[ content_size ]                      content
;}
;*buffer -> strucBuffersNormal
;{
;: 0x00 .size                           dw                                      content_size in [0x0001, 0x7fd6]
;: 0x02 .                               db[ content_size ]                      content
;}
;*buffer -> strucBuffersBigfoo
;{
;: 0x00 .size                           cw                                      magicBigFoo
;: 0x02 .buffer                         dq                                      *content
;: 0x0a .sizeUsed                       dd                                      used_size
;: 0x12 .sizePage                       dd                                      page_size
;}
;*buffer -> strucBuffersBigfooRemoved
;{
;: 0x00 .size                           cw                                      magicBigFooRemoved
;: 0x02 .buffer                         cq                                      invalid
;: 0x0a .sizePage                       cd                                      invalid
;: 0x12 .sizeBuffer                     cd                                      invalid
;}
;*buffer -> strucBuffersRemoved
;{
;: 0x00 .size                           dw                                      content_size in [0x802a, 0xffff]
;: 0x02 .                               db[ content_size ]                      invalid
;}
;*buffer -> strucBuffersInvalid
;{
;: 0x00 .size                           dw                                      content_size in {0x0000, [0x7fd7, 0x7fff], [0x8002, 0x8029]}
;: 0x02 .                               db[ content_size ]                      invalid
;}
buffers:
  .theAddress                           fix                                     rax
  .theAddress_d                         fix                                     eax
  .theAddress_w                         fix                                     ax
  .theAddress_b                         fix                                     al
  .theChar                              fix                                     rax
  .theChar_d                            fix                                     eax
  .theChar_w                            fix                                     ax
  .theChar_b                            fix                                     al
  .theLength                            fix                                     rax
  .theLength_d                          fix                                     eax
  .theLength_w                          fix                                     ax
  .theLength_b                          fix                                     al
  .theOffset                            fix                                     rsi
  .theOffset_d                          fix                                     esi
  .theOffset_w                          fix                                     si
  .theOffset_b                          fix                                     sil
  .theValue                             fix                                     rax
  .theValue_d                           fix                                     eax
  .theValue_w                           fix                                     ax
  .theValue_b                           fix                                     al
  .theContent                           fix                                     rbx
  .theContent_d                         fix                                     ebx
  .theContent_w                         fix                                     bx
  .theContent_b                         fix                                     bl
  .theContentSize                       fix                                     rcx
  .theContentSize_d                     fix                                     ecx
  .theContentSize_w                     fix                                     cx
  .theContentSize_b                     fix                                     cl
  .theInputSize                         fix                                     rdx
  .theInputSize_d                       fix                                     edx
  .theInputSize_w                       fix                                     dx
  .theInput                             fix                                     rsi
  .theInput_d                           fix                                     esi
  .theInput_w                           fix                                     si
  .theInput_b                           fix                                     sil
  .theBuffer                            fix                                     rdi
  .theBuffer_d                          fix                                     edi
  .theBuffer_w                          fix                                     di
  .theBuffer_b                          fix                                     dil
  ;match ,__page__
  ;{
    .thePage                            fix                                     r15
  ;}
  ;match any,__page__
  ;{
  ;: .thePage                            fix                                     __page__
  ;}
;: .thePage_d                            fix                                     r15d
;: .thePage_w                            fix                                     r15w
;: .thePage_b                            fix                                     r15b
  .clone:
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 unchanged
    ;:  rbx                             ignored                                 *content_new
    ;:  rcx                             ignored                                 content_size_new
    ;:  rdx                             length                                  content_size_new
    ;:  rsi                             offset                                  *content_old + content_size_new
    ;:  rdi                             *buffer                                 *buffer_new
    ;:  r15                             ignored                                 *page_new
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
    ;< insufficient audited function, use with caution >
    ;( clone *buffer )
      call                              .get
      ;( if *buffer is removed -> failRemoved )
        jc                              .failRemoved
      .clone.fast:
        ;( if content_size - offset <= NULL -> failBoundaries )
          sub                           .theContentSize,                        .theOffset
          jle                           .failBoundaries
        ;( if length > content_size -> failBoundaries )
          cmp                           .theInputSize,                          .theContentSize
          ja                            .failBoundaries
        ;( if length = NULL -> length = content_size )
          or                            .theInputSize,                          .theInputSize
          cmove                         .theInputSize,                          .theContentSize
        ;( else -> size = length )
          cmovne                        .theContentSize,                        .theInputSize
        ;( clone )
          lea                           .theInput,                              [ .theContent + .theOffset ]
          call                          .new
      ret
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 unchanged
    ;:  rbx                             ignored                                 *content_new
    ;:  rcx                             ignored                                 content_size_new
    ;:  rdx                             length                                  content_size_new
    ;:  rsi                             offset                                  *content_old + content_size_new
    ;:  rdi                             *buffer                                 *buffer_new
    ;:  r15                             ignored                                 *page_new
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
  onDebug
  {
    .debug:
      ;< insufficient audited function, insufficient audited function >
      ;( debug pages )
        ;( debug header-structure )
          echo_put                      .msgList
          echo_hexValue                 .list,                                  8
          echo_put                      .msgLastPage
          echo_hexValue                 .lastPage,                              8
          echo_put                      .msgLastItem
          echo_hexValue                 .last,                                  8
          echo_put                      .msgSumFull
          echo_hexValue                 .full,                                  4
          echo_put                      .msgSumFree
          echo_hexValue                 .free,                                  4
          echo_put                      .msgSumMeta
          echo_hexValue                 .meta,                                  4
          echo_put                      .msgSumUsed
          echo_hexValue                 .used,                                  4
          echo_put                      .msgSumSpam
          echo_hexValue                 .spam,                                  4
          echo_put                      .msgCounter
          echo_hexValue                 .count,                                 4
          ;echo_n
        ;( debug pages )
          mov                           .thePage,                               qword [ .list ]
          .debug.pages:
            mov                         qword [ .save ],                        .thePage
            ;( if last page -> debug.final )
              or                        .thePage,                               .thePage
              jz                        .debug.final
            echo_put                    .msgStart
            echo_hexValue               .save,                                  8
            echo_put                    .msgStop
            echo_hexValue               ( .thePage + .offStop ),                8
            echo_put                    .msgHere
            echo_hexValue               ( .thePage + .offHere ),                8
            echo_put                    .msgLast
            echo_hexValue               ( .thePage + .offLast ),                8
            echo_put                    .msgFull
            echo_hexValue               ( .thePage + .offFull ),                2
            echo_put                    .msgFree
            echo_hexValue               ( .thePage + .offFree ),                2
            echo_put                    .msgUsed
            echo_hexValue               ( .thePage + .offUsed ),                2
            echo_put                    .msgSpam
            echo_hexValue               ( .thePage + .offSpam ),                2
        ;( final )
          .debug.final:
          echo_n
          ret
  }
  .del:
  .delete:
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 unchanged
    ;:  rbx                             ignored                                 invalid *content
    ;:  rcx                             ignored                                 removed_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 invalid *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 undefined
    ;}
    ;< insufficient audited function, use with caution >
    ;( delete *buffer )
      call                              .get
      ;( if *buffer is removed -> failRemoved )
        jc                              .failRemoved
      ;( if *buffer is bigfoo -> delete.bigfoo )
        jz                              .delete.bigfoo
      ;( config buffer-structure )
        ;{
        ;: 0x00 .size                   cw                                      - .size
        ;: 0x02 .                       db[ content_size - 2 ]                  ?
        ;}
      .delete.fast:
        neg                             .theContentSize
        mov                             word  [ .theBuffer + .offSize ],        .theContentSize_w
      .delete.normal:
        ;( config heap-structure )
          ;{
          ;: 0x00 .list                 aq -> strucBuffersPage                  ?
          ;: 0x08 .full                 ad                                      ?
          ;: 0x0a .used                 ad                                      + ( 0 - size - 2 )
          ;: 0x10 .meta                 ad                                      ?
          ;: 0x14 .spam                 ad                                      ?
          ;: 0x18 .free                 ad                                      ?
          ;: 0x1a .count                ad                                      - 1
          ;:      .lastPage             aq -> strucBuffersPage                  ?
          ;:      .last                 aq -> strucBuffers                      ?
          ;}
          sub                           .theContentSize,                        2
          add                           dword [ .used ],                        .theContentSize_d
          dec                           dword [ .count ]
        ;( config page )
          ;{
          ;: 0x00 .next                 cq -> strucBuffersPage                  ?
          ;: 0x08 .stop                 cq -> void                              ?
          ;: 0x10 .here                 dq -> strucBuffers                      ?
          ;: 0x18 .last                 dq -> strucBuffers                      ?
          ;: 0x20 .full                 cw                                      ?
          ;: 0x22 .free                 dw                                      ?
          ;: 0x24 .used                 dw                                      + ( 0 - content_size - 2 )
          ;: 0x26 .spam                 dw                                      ?
          ;: 0x28 .                     db[ page_size - meta_size ]             ?
          ;}
          add                           word  [ .thePage + .offUsed ],          .theContentSize_w
        ;( if *page.last != *buffer -> delete.inefficient )
          cmp                           qword [ .thePage + .offLast ],          .theBuffer
          jne                           .delete.inefficient
        .delete.efficient:
          ;( config buffer-structure )
            ;{
            ;: 0x00 .size               cw                                      0x0000
            ;: 0x02 .                   db[ buffer_size - 2 ]                   ?
            ;}
            mov                         word  [ .theBuffer + .offSize ],        0x0000
          ;( config heap-structure )
            ;{
            ;: 0x00 .list               aq -> strucBuffersPage                  ?
            ;: 0x08 .full               ad                                      ?
            ;: 0x0a .used               ad                                      ?
            ;: 0x10 .meta               ad                                      ?
            ;: 0x14 .spam               ad                                      ?
            ;: 0x18 .free               ad                                      - ( 0 - content_size - 2 )
            ;: 0x1a .count              ad                                      ?
            ;:      .lastPage           aq -> strucBuffersPage                  ?
            ;:      .last               aq -> strucBuffers                      ?
            ;}
            sub                         dword [ .free ],                        .theContentSize_d
          ;( config page-structure )
            ;{
            ;: 0x00 .next               cq -> strucBuffersPage                  ?
            ;: 0x08 .stop               cq -> void                              ?
            ;: 0x10 .here               dq -> strucBuffers                      + ( 0 - content_size - 2 )
            ;: 0x18 .last               dq -> strucBuffers                      ?
            ;: 0x20 .full               cw                                      ?
            ;: 0x22 .free               dw                                      - ( 0 - content_size - 2 )
            ;: 0x24 .used               dw                                      ?
            ;: 0x26 .spam               dw                                      ?
            ;: 0x28 .                   db[ page_size - meta_size ]             ?
            ;}
            add                         qword [ .thePage + .offHere ],          .theContentSize
            sub                         word  [ .thePage + .offFree ],          .theContentSize_w
          ret
        .delete.inefficient:
          ;( config heap-structure )
            ;{
            ;: 0x00 .list               aq -> strucBuffersPage                  ?
            ;: 0x08 .full               ad                                      ?
            ;: 0x0a .used               ad                                      ?
            ;: 0x10 .meta               ad                                      ?
            ;: 0x14 .spam               ad                                      - ( 0 - content_size - 2 )
            ;: 0x18 .free               ad                                      ?
            ;: 0x1a .count              ad                                      ?
            ;:      .lastPage           aq -> strucBuffersPage                  ?
            ;:      .last               aq -> strucBuffers                      ?
            ;}
            sub                         dword [ .spam ],                        .theContentSize_d
          ;( config page-structure )
            ;{
            ;: 0x00 .next               cq -> strucBuffersPage                  ?
            ;: 0x08 .stop               cq -> void                              ?
            ;: 0x10 .here               dq -> strucBuffers                      ?
            ;: 0x18 .last               dq -> strucBuffers                      ?
            ;: 0x20 .full               cw                                      ?
            ;: 0x22 .free               dw                                      ?
            ;: 0x24 .used               dw                                      ?
            ;: 0x26 .spam               dw                                      - ( 0 - content_size - 2 )
            ;: 0x28 .                   db[ page_size - meta_size ]             ?
            ;}
            sub                         word  [ .thePage + .offSpam ],          .theContentSize_w
          ret
        .delete.bigfoo:
          ;( config heap-structure )
            ;{
            ;: 0x00 .list               aq -> strucBuffersPage                  ?
            ;: 0x08 .full               ad                                      - page_size
            ;: 0x0a .used               ad                                      - content_size
            ;: 0x10 .meta               ad                                      ?
            ;: 0x14 .spam               ad                                      ?
            ;: 0x18 .free               ad                                      ?
            ;: 0x1a .count              ad                                      ?
            ;:      .lastPage           aq -> strucBuffersPage                  ?
            ;:      .last               aq -> strucBuffers                      ?
            ;}
            sub                         dword [ .used ],                        .theContentSize_d
            mov                         .theContentSize_d,                      dword [ .theBuffer + .offBigPage ]
            sub                         dword [ .full ],                        .theContentSize_d
          ;( remove *content )
            push                        rax
            push                        .theContentSize
            push                        .theContent                             ;manpage says its not needed, but just in case
            push                        .theInputSize
            push                        .theInput
            push                        .theBuffer
              mov                       sys1arg,                                .theContentSize
              mov                       sys0arg,                                .theContent
              sys_call                  sys_munmap
              ;( if sys0ret = ERRNO -> .delete.bigfoo.fail )
                or                      sys0ret,                                sys0ret
                js                      .delete.bigfoo.fail
            pop                         .theBuffer
            pop                         .theInput
            pop                         .theInputSize
            pop                         .theContent
            pop                         .theContentSize
            pop                         rax
          ;( remove entry )
            mov                         .theContentSize,                        ( 0 - .lenBigFoo )
            mov                         word  [ .theBuffer + .offSize ],        .magicBigFooRemoved
            jmp                         .delete.normal
        .delete.bigfoo.fail:
          mov                           word  [ .theBuffer + .offSize ],        .magicBigFoo                            ;mark buffer as removed bigfoo
          add                           rsp,                                    ( 6 * 8 )                               ;pop 6 qwords to void
          jmp                           .failInternal
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 unchanged
    ;:  rbx                             ignored                                 invalid *content
    ;:  rcx                             ignored                                 ( 0 - removed_size )
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 invalid *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 undefined
    ;}
  .echo:
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 NULL/error
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
    ;< insufficient audited function, use with caution >
    ;( echo buffer to stdout )
      call                              .get
      ;( if *buffer is removed -> failRemoved )
        jc                              .failRemoved
      push                              sys1arg
      push                              sys2arg
      push                              rcx
        mov                             sys2arg,                                .theContentSize
        mov                             sys1arg,                                .theContent
        mov                             sys0arg,                                STDOUT
        sys_call                        sys_write
      pop                               rcx
      pop                               sys2arg
      pop                               sys1arg
      ret
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 NULL/error
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
  .echo0:
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 NULL/error
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
    ;< insufficient audited function, use with caution >
    ;( echo buffer to stdout )
      call                              .get
      ;( if *buffer is removed -> failRemoved )
        jc                              .failRemoved
      push                              sys1arg
      push                              sys2arg
      push                              rcx
        lea                             sys2arg,                                [ .theContentSize - 1 ]
        mov                             sys1arg,                                .theContent
        mov                             sys0arg,                                STDOUT
        sys_call                        sys_write
      pop                               rcx
      pop                               sys2arg
      pop                               sys1arg
      ret
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 NULL/error
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
  .extend:
    ;( I/O )
    ;{
    ;:  rax                             length                                  length
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             input_size                              input_size
    ;:  rsi                             *input                                  *input
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
    ;< insufficient audited function, use with caution >
    ;( extend *buffer )
      call                              .get
      ;( if *buffer is removed -> failRemoved )
        jc                              .failRemoved
      ;( if *buffer is bigfoo -> extend.bigfoo )
        jz                              .extend.bigfoo
      .extend.normal:
        ;( if *page_last != *buffer -> extend.inefficient )
          cmp                           qword [ .thePage + .offLast ],          .theBuffer
          jne                           .extend.normal.inefficient
        ;( if free_size < length -> extend.inefficient )
          cmp                           word  [ .thePage + .offFree ],          .theLength_w
          jb                            .extend.normal.inefficient
        .extend.normal.efficient:
          add                           .theContentSize,                        .theLength
          cmp                           .theContentSize,                        .startInvalid
          jae                           .extend.bigfoo
          ;( config heap-structure )
            ;{
            ;: 0x00 .list               aq -> strucBuffersPage                  ?
            ;: 0x08 .full               ad                                      ?
            ;: 0x0a .used               ad                                      + length
            ;: 0x10 .meta               ad                                      ?
            ;: 0x14 .spam               ad                                      ?
            ;: 0x18 .free               ad                                      - length
            ;: 0x1a .count              ad                                      ?
            ;:      .lastPage           aq -> strucBuffersPage                  *page
            ;:      .last               aq -> strucBuffers                      *buffer
            ;}
            add                         dword [ .used ],                        .theLength_d
            sub                         dword [ .free ],                        .theLength_d
            ;mov                         qword [ .lastPage ],                    .thePage
            ;mov                         qword [ .last ],                        .theBuffer
          ;( config page-structure )
            ;{
            ;: 0x00 .next               cq -> strucBuffersPage                  ?
            ;: 0x08 .stop               cq -> void                              ?
            ;: 0x10 .here               dq -> strucBuffers                      + length
            ;: 0x18 .last               dq -> strucBuffers                      ?
            ;: 0x20 .full               cw                                      ?
            ;: 0x22 .free               dw                                      - length
            ;: 0x24 .used               dw                                      + length
            ;: 0x26 .spam               dw                                      ?
            ;: 0x28 .                   db[ page_size - meta_size ]             ?
            ;}
            sub                         word  [ .thePage + .offFree ],          .theLength_w
            add                         word  [ .thePage + .offUsed ],          .theLength_w
            add                         qword [ .thePage + .offHere ],          .theLength
          ;( config buffer-structure )
            ;{
            ;: 0x00 .size               dw                                      + length
            ;: 0x02 .                   db[ content_size ]                      ?
            ;}
            mov                         word  [ .theBuffer + .offSize ],        .theContentSize_w
          jmp                           .extend.normal.both
        .extend.normal.inefficient:
          neg                           .theContentSize
          sub                           .theContentSize,                        2
          ;( config heap-structure )
            ;{
            ;: 0x00 .list               aq -> strucBuffersPage                  ?
            ;: 0x08 .full               ad                                      ?
            ;: 0x0a .used               ad                                      + ( 0 - size - 2 )
            ;: 0x10 .meta               ad                                      ?
            ;: 0x14 .spam               ad                                      - ( 0 - size - 2 )
            ;: 0x18 .free               ad                                      ?
            ;: 0x1a .count              ad                                      - 1
            ;:      .lastPage           aq -> strucBuffersPage                  ?
            ;:      .last               aq -> strucBuffers                      ?
            ;}
            sub                         dword [ .spam ],                        .theContentSize_d
            add                         dword [ .used ],                        .theContentSize_d
            dec                         dword [ .count ]
          ;( config page-structure )
            ;{
            ;: 0x00 .next               cq -> strucBuffersPage                  ?
            ;: 0x08 .stop               cq -> void                              ?
            ;: 0x10 .here               dq -> strucBuffers                      = *last
            ;: 0x18 .last               dq -> strucBuffers                      ?
            ;: 0x20 .full               cw                                      ?
            ;: 0x22 .free               dw                                      ?
            ;: 0x24 .used               dw                                      + ( 0 - size - 2 )
            ;: 0x26 .spam               dw                                      - ( 0 - size - 2 )
            ;: 0x28 .                   db[ page_size - meta_size ]             ?
            ;}
;            mov                         .theBuffer,                             qword [ .thePage + .offLast ]
            add                         word  [ .thePage + .offUsed ],          .theContentSize_w
;            mov                         qword [ .thePage + .offLast ],          .theBuffer
            sub                         word  [ .thePage + .offSpam ],          .theContentSize_w
          add                           .theContentSize,                        2
          ;( config buffer-structure )
            ;{
            ;: 0x00 .size               dw                                      = ( 0 - size )
            ;: 0x02 .                   db[ content_size ]                      ?
            ;}
            mov                         word  [ .theBuffer + .offSize ],        .theContentSize_w
          neg                           .theContentSize
          push                          .theInputSize
          push                          .theInput
            mov                         .theInputSize,                          .theContentSize
            mov                         .theInput,                              .theContent
            add                         .theContentSize,                        .theLength
            call                        .new
          pop                           .theInput
          pop                           .theInputSize
          jc                            .failSafe
        .extend.normal.both:
          sub                           .theLength,                             .theContentSize
          neg                           .theLength
          push                          .theBuffer
            xchg                        .theContentSize,                        .theInputSize                           ;rcx = input-size
            lea                         rdi,                                    [ .theContent + .theLength ]            ;rdi = *content.end
            rep                         movsb
            mov                         .theContentSize,                        .theInputSize                           ;old content-size
          pop                           .theBuffer
          clc                           ;CF                                     False
          or                            .thePage,                               .thePage
                                        ;ZF                                     False
          ret
        .extend.bigfoo:
          jmp                           .failImplementation
          ret
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 unchanged
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             length                                  content_size
    ;:  rdx                             input_size                              input_size
    ;:  rsi                             *input                                  *input
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
  .get:
  .is:
  .len:
  .length:
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 unchanged
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
    ;< insufficient audited function, use with caution >
    ;( find *buffer and get pointers )
      ;( if *buffer = NULL -> failNull )
        or                              rdi,                                    rdi
        jz                              .failNull
      ;( if *last != *buffer -> get.slow )
        cmp                             qword [ .last ],                        .theBuffer
        jne                             .get.slow
      .get.fast:
        mov                             .thePage,                               qword [ .lastPage ]
        jmp                             .get.length
      .get.slow:
        mov                             .thePage,                               qword [ .list ]
        ;;( if not initialized -> failInit )
        ;: or                            .thePage,                               .thePage
        ;: jz                            .failInit
        .get.while:
          ;( if *buffer not in [*page, *page_stop - 1 ] -> get.next )
            cmp                         .thePage,                               .theBuffer
            ja                          .get.next
            cmp                         .theBuffer,                             qword [ .thePage + .offStop ]
            jae                         .get.next
            jmp                         .get.length
        .get.next:
          ;( *page = *page_next )
            mov                         .thePage,                               qword [ .thePage + .offNext ]
          ;( if *page = NULL -> failInvalid )
            or                          .thePage,                               .thePage
            jz                          .failInvalid
          jmp                           .get.while
      .get.length:
        movzx                           .theContentSize,                        word  [ .theBuffer + .offSize ]
        ;( if content_size = magicBigFoo -> get.bigfoo )
          cmp                           .theContentSize,                        .magicBigFoo
          je                            .get.bigfoo
        ;( if content_size = magicBigFooRemoved -> failRemoved )
          cmp                           .theContentSize,                        .magicBigFooRemoved
          je                            .failRemoved
        ;( if content_size >= startNegativ -> get.removed )
          cmp                           .theContentSize,                        .startNegativ
          jae                           .get.removed
        ;( if content_size >= startInvalid -> failInvalid )
          cmp                           .theContentSize,                        .startInvalid
          jae                           .failInvalid
        .get.normal:
          lea                           .theContent,                            [ .theBuffer + .offNormal ]
          or                            .theContent,                            .theContent
          clc                           ;CF                                     False
                                        ;ZF                                     False, because of or
          ret
        .get.removed:
          lea                           .theContent,                            [ .theBuffer + .offNormal ]
          stc                           ;CF                                     True
                                        ;ZF                                     Undefined
          ret
        .get.bigfoo:
          mov                           .theContent,                            qword [ .theBuffer + .offBigFoo ]
          mov                           .theContentSize_d,                      dword [ .theBuffer + .offBigUsed ]
          clc                           ;CF                                     False
                                        ;ZF                                     True, because of je
          ret
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 unchanged
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
  .create:
  .new:
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 unchanged
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             length                                  content_size
    ;:  rdx                             input_size                              input_size
    ;:  rsi                             *input                                  *input + input_size
    ;:  rdi                             ignored                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
    ;< insufficient audited function, use with caution >
    ;( create new *buffer and get pointers )
      mov                               .thePage,                               qword [ .list ]
      .new.look:
        ;( if input_size > ( lenFree - 2 ) -> new.bigfoo )
          cmp                           .theContentSize,                        ( .lenFree - 2 )
          ja                            .new.bigfoo
          add                           .theContentSize,                        2
      .new.while:
        ;( if word  [ *page + offFree ] >= input_size -> new.normal )
          cmp                           word  [ .thePage + .offFree ],          .theContentSize_w
          jae                           .new.normal
        mov                             qword [ .save ],                        .thePage
        mov                             .thePage,                               qword [ .thePage + .offNext ]
        ;( if *page = NULL -> new.create )
          or                            .thePage,                               .thePage
          jz                            .new.create
        jmp                             .new.while                                                                      ;kind of optimization
      .new.create:
        mov                             .thePage,                               qword [ .save ]
        push                            rax
        push                            .theInputSize
        push                            .theInput
        push                            .theContentSize
          mov                           sys4arg,                                ( 0 - 1 )
          mov                           sys3arg,                                0x0000000000000022                      ;anonymous, private
          mov                           sys2arg,                                0x0000000000000003                      ;read, write
          mov                           sys1arg,                                ( 4096 * .ctrPage )
          sys_call                      sys_mmap
          onError_put
          ;( *buffer <= sys0ret )
            mov                         .theBuffer,                             sys0ret
        pop                             .theContentSize
        pop                             .theInput
        pop                             .theInputSize
        pop                             rax
        ;( if *buffer = ERRNO -> failInternal )
          or                            .theBuffer,                             .theBuffer
          js                            .failInternal
        ;( config heap-structure )
          ;{
          ;: 0x00 .list                 aq -> strucBuffersPage                  *page
          ;: 0x08 .full                 ad                                      + lenFull
          ;: 0x0a .used                 ad                                      + 0x00000000
          ;: 0x10 .meta                 ad                                      + lenMeta
          ;: 0x14 .spam                 ad                                      + 0x00000000
          ;: 0x18 .free                 ad                                      + lenFree
          ;: 0x1a .count                ad                                      + 0x00000000
          ;:      .lastPage             aq -> strucBuffersPage                  ?
          ;:      .last                 aq -> strucBuffers                      ?
          ;}
          add                           qword [ .full ],                        .lenFull
          add                           qword [ .meta ],                        .lenMeta
          add                           qword [ .free ],                        .lenFree
        ;( config current page-structure and go to the next page )
          ;{
          ;: 0x00 .next                 cq -> strucBuffersPage                  *next_page
          ;: 0x08 .stop                 cq -> void                              ?
          ;: 0x10 .here                 dq -> strucBuffers                      ?
          ;: 0x18 .last                 dq -> strucBuffers                      ?
          ;: 0x20 .full                 cw                                      ?
          ;: 0x22 .free                 dw                                      ?
          ;: 0x24 .used                 dw                                      ?
          ;: 0x26 .spam                 dw                                      ?
          ;: 0x28 .                     db[ page_size - meta_size ]             ?
          ;}
          mov                           qword [ .thePage + .offNext ],          .theBuffer
          mov                           .thePage,                               .theBuffer
        ;( config next page-structure )
          ;{
          ;: 0x00 .next                 cq -> strucBuffersPage                  0x0000000000000000
          ;: 0x08 .stop                 cq -> void                              *page + lenFull
          ;: 0x10 .here                 dq -> strucBuffers                      *page + lenMeta
          ;: 0x18 .last                 dq -> strucBuffers                      ?
          ;: 0x20 .full                 cw                                      lenFull
          ;: 0x22 .free                 dw                                      lenFree
          ;: 0x24 .used                 dw                                      0x0000
          ;: 0x26 .spam                 dw                                      0x0000
          ;: 0x28 .                     db[ page_size - meta_size ]             ?
          ;}
          mov                           qword [ .thePage + .offNext ],          0x0000000000000000
          add                           .theBuffer,                             .lenFull
          mov                           qword [ .thePage + .offStop ],          .theBuffer
          sub                           .theBuffer,                             .lenFree
          mov                           qword [ .thePage + .offHere ],          .theBuffer
          mov                           qword [ .thePage + .offFull ],          (( .lenFull ) + ( 0x10000 * .lenFree ))
      .new.normal:
        mov                             .theBuffer,                             qword [ .thePage + .offHere ]
        ;( config heap-structure )
          ;{
          ;: 0x00 .list                 aq -> strucBuffersPage                  ?
          ;: 0x08 .full                 ad                                      ?
          ;: 0x0a .used                 ad                                      + input_size + 2
          ;: 0x10 .meta                 ad                                      ?
          ;: 0x14 .spam                 ad                                      ?
          ;: 0x18 .free                 ad                                      - input_size - 2
          ;: 0x1a .count                ad                                      + 1
          ;:      .lastPage             aq -> strucBuffersPage                  *page
          ;:      .last                 aq -> strucBuffers                      *buffer
          ;}
          sub                           dword [ .free ],                        .theContentSize_d
          add                           dword [ .used ],                        .theContentSize_d
          inc                           dword [ .count ]
          mov                           qword [ .lastPage ],                    .thePage
          mov                           qword [ .last ],                        .theBuffer
        ;( config page-structure )
          ;{
          ;: 0x00 .next                 cq -> strucBuffersPage                  ?
          ;: 0x08 .stop                 cq -> void                              ?
          ;: 0x10 .here                 dq -> strucBuffers                      + input_size + 2
          ;: 0x18 .last                 dq -> strucBuffers                      *buffer
          ;: 0x20 .full                 cw                                      ?
          ;: 0x22 .free                 dw                                      - input_size - 2
          ;: 0x24 .used                 dw                                      + input_size + 2
          ;: 0x26 .spam                 dw                                      ?
          ;: 0x28 .                     db[ page_size - meta_size ]             ?
          ;}
          sub                           word  [ .thePage + .offFree ],          .theContentSize_w
          add                           word  [ .thePage + .offUsed ],          .theContentSize_w
          add                           qword [ .thePage + .offHere ],          .theContentSize
          mov                           qword [ .thePage + .offLast ],          .theBuffer
        ;( config buffer-structure )
          ;{
          ;: 0x00 .size                 dw                                      intput_size
          ;: 0x02 .                     db[ content_size - 2 ]                  ?
          ;}
          sub                           .theContentSize,                        2
          mov                           word  [ .theBuffer + .offSize ],        .theContentSize_w
          lea                           .theContent,                            [ .theBuffer + 2 ]
          ;( if input_size = NULL or *input = NULL -> new.normal.setFlags )
            or                          .theInputSize,                          .theInputSize
            jz                          .new.normal.setFlags
            or                          .theInput,                              .theInput
            jz                          .new.normal.setFlags
          ;( else )
            push                        rax
            push                        rcx
            push                        rdi
              ;( if input_size < length -> counter = input_size )
                cmp                     .theInputSize,                          .theContentSize
                cmovb                   rcx,                                    .theInputSize
              ;( else -> counter = length )
                ;well, nothing to do here
              ;( and fill it )
                mov                     rdi,                                    .theContent
                rep                     movsb
            pop                         rdi
            pop                         rcx
            pop                         rax
        ;( set flags )
          .new.normal.setFlags:
            clc                         ;CF                                     False
                                        ;ZF                                     False, because of or, jz
        ret
      .new.bigfoo:
        push                            rax
        push                            .theContentSize
        push                            .theInputSize
        push                            .theInput
          mov                           .theContentSize,                        .lenBigFoo
          xor                           .theInputSize,                          .theInputSize
          call                          .new.while
        pop                             .theInput
        pop                             .theInputSize
        pop                             .theContentSize
        pop                             rax
        ;( if failed -> new.bigfoo.justReturn )
          jc                            .new.bigfoo.justReturn
        push                            rax
        push                            rdi
          push                          .theContentSize
          push                          .theInputSize
          push                          .theInput
            push                        .theBuffer
              add                       dword [ .used ],                        .theContentSize_d                       ;config heap-structure, inc .used by length
              sub                       dword [ .free ],                        .theContentSize_d                       ;config heap-structure, dec .free by length
              mov                       qword [ .theBuffer + .offBigUsed ],     .theContentSize                         ;config buffer-structure, set .sizeUsed to length
              test                      .theContentSize,                        0x0000000000000fff
              jz                        @f
                add                     .theContentSize,                        0x0000000000001000
                and                     .theContentSize,                        0xfffffffffffff000
              @@:
              add                       dword [ .full ],                        .theContentSize_d                       ;config heap-structure, inc .full by aligned length
              add                       dword [ .free ],                        .theContentSize_d                       ;config heap-structure, inc .free by aligned length
              mov                       sys1arg,                                .theContentSize
              mov                       qword [ .theBuffer + .offBigPage ],     .theContentSize                         ;config buffer-structure, set .sizePage to aligned length
              xor                       sys5arg,                                sys5arg
              mov                       sys4arg,                                0xffffffffffffffff
              mov                       sys3arg,                                0x0000000000000022                      ;private, anonymous
              mov                       sys2arg,                                0x0000000000000003                      ;read, write
              xor                       sys0arg,                                sys0arg
              sys_call                  sys_mmap
            pop                         .theBuffer
            ;( if sys0ret = ERRNO -> new.bigfoo.failInternal )
              or                        sys0ret,                                sys0ret
              js                        .new.bigfoo.failInternal
            ;( config heap-structure )
              ;{
              ;: 0x00 .list             aq -> strucBuffersPage                  ?
              ;: 0x08 .full             ad                                      + align(input_size)
              ;: 0x0a .used             ad                                      + input_size
              ;: 0x10 .meta             ad                                      ?
              ;: 0x14 .spam             ad                                      ?
              ;: 0x18 .free             ad                                      + align(input_size) - input_size
              ;: 0x1a .count            ad                                      ?
              ;:      .lastPage         aq -> strucBuffersPage                  ?
              ;:      .last             aq -> strucBuffers                      ?
              ;}
            ;( config buffer-structure )
              ;{
              ;: 0x00 .size             cw                                      magicBigFoo
              ;: 0x02 .buffer           dq                                      *content
              ;: 0x0a .sizeUsed         dd                                      used_size
              ;: 0x12 .sizePage         dd                                      page_size
              ;}
              mov                       word  [ .theBuffer + .offSize ],        .magicBigFoo
              mov                       qword [ .theBuffer + .offBigFoo ],      sys0ret
              mov                       .theContent,                            sys0ret
          pop                           .theInput
          pop                           .theInputSize
          pop                           .theContentSize
          ;( if input_size = NULL or *input = NULL -> new.bigfoo.next )
            or                          .theInputSize,                          .theInputSize
            jz                          .new.bigfoo.next
            or                          .theInput,                              .theInput
            jz                          .new.bigfoo.next
          ;( else )
            ;( if input_size < length -> counter = input_size )
              cmp                       .theInputSize,                          .theLength
              cmovb                     rcx,                                    .theInputSize
            ;( else -> counter = length )
              ;well, nothing to do here
            ;( and fill it )
              mov                       rdi,                                    .theContent
              rep                       movsb
            ;( set ZF )
              or                        rcx,                                    rcx
          .new.bigfoo.next:
        push                            rdi
        push                            rax
        mov                             .theContentSize,                        qword [ .theBuffer + .offBigUsed ]
        clc                             ;CF                                     False
                                        ;ZF                                     True, because of jz or or
      .new.bigfoo.justReturn:
        ret
      .new.bigfoo.failInternal:
        mov                             word  [ .theBuffer + .offSize ],        .magicBigFoo                            ;mark buffer as removed bigfoo
        add                             rsp,                                    ( 5 * 8 )                               ;pop 5 qwords to void
        jmp                             .failInternal
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 unchanged
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             length                                  content_size
    ;:  rdx                             input_size                              input_size
    ;:  rsi                             *input                                  *input + input_size
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
  .put.failSafe:
    add                                 rsp,                                    ( 2 * 8 )
    ret
  .putB:
  .putByte:
    ;( I/O )
    ;{
    ;:  rax                        byte char                               byte char
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
    ;< insufficient audited function, use with caution >
    ;( put byte char at the end of *buffer )
      call                              .get
      ;( if *buffer is removed -> failRemoved )
        jc                              .failRemoved
      ;( if *buffer is bigfoo -> putQ.bigfoo )
        jz                              .putB.bigfoo
    ;{
    ;:  rax                        byte char
    ;:  rbx                             *content
    ;:  rcx                             content_size
    ;:  rdx                             unchanged
    ;:  rsi                             unchanged
    ;:  rdi                             *buffer
    ;:  r15                             *page
    ;:  CF                              set if failed
    ;:  ZF                              set if bigfoo, clr if normal
    ;}
      .putB.normal:
        ;( save some registers )
          push                          rdx
          push                          rsi
        ;( if *page_last != *buffer -> putB.normal.inefficient )
          cmp                           qword [ .thePage + .offLast ],          .theBuffer
          jne                           .putB.normal.inefficient
        ;( if free_size < 1 -> putB.normal.inefficient )
          cmp                           word  [ .thePage + .offFree ],          1
          jb                            .putB.normal.inefficient
        .putB.normal.efficient:
          ;( config heap-structure )
            ;{
            ;: 0x00 .list               aq -> strucBuffersPage                  ?
            ;: 0x08 .full               ad                                      ?
            ;: 0x0a .used               ad                                      + 1
            ;: 0x10 .meta               ad                                      ?
            ;: 0x14 .spam               ad                                      ?
            ;: 0x18 .free               ad                                      - 1
            ;: 0x1a .count              ad                                      ?
            ;:      .lastPage           aq -> strucBuffersPage                  *page
            ;:      .last               aq -> strucBuffers                      *buffer
            ;}
            inc                         dword [ .used ]
            dec                         dword [ .free ]
            ;mov                         qword [ .lastPage ],                    .thePage
            ;mov                         qword [ .last ],                        .theBuffer
          ;( config page-structure )
            ;{
            ;: 0x00 .next               cq -> strucBuffersPage                  ?
            ;: 0x08 .stop               cq -> void                              ?
            ;: 0x10 .here               dq -> strucBuffers                      + 1
            ;: 0x18 .last               dq -> strucBuffers                      ?
            ;: 0x20 .full               cw                                      ?
            ;: 0x22 .free               dw                                      - 1
            ;: 0x24 .used               dw                                      + 1
            ;: 0x26 .spam               dw                                      ?
            ;: 0x28 .                   db[ page_size - meta_size ]             ?
            ;}
            inc                         qword [ .thePage + .offHere ]
            dec                         word  [ .thePage + .offFree ]
            inc                         word  [ .thePage + .offUsed ]
          ;( config buffer-structure )
            ;{
            ;: 0x00 .size               dw                                      + 1
            ;: 0x02 .                   db[ content_size - 2 ]                  ?
            ;}
            inc                         word  [ .theBuffer + .offSize ]
          inc                           .theContentSize
          jmp                           .putB.normal.both
        .putB.normal.inefficient:
          ;( remove old *buffer )
            neg                         .theContentSize
            sub                         .theContentSize,                        2
            ;( config heap-structure )
              ;{
              ;: 0x00 .list             aq -> strucBuffersPage                  ?
              ;: 0x08 .full             ad                                      ?
              ;: 0x0a .used             ad                                      + ( 0 - size - 2 )
              ;: 0x10 .meta             ad                                      ?
              ;: 0x14 .spam             ad                                      - ( 0 - size - 2 )
              ;: 0x18 .free             ad                                      ?
              ;: 0x1a .count            ad                                      - 1
              ;:      .lastPage         aq -> strucBuffersPage                  ?
              ;:      .last             aq -> strucBuffers                      ?
              ;}
              sub                       dword [ .spam ],                        .theContentSize_d
              add                       dword [ .used ],                        .theContentSize_d
              dec                       dword [ .count ]
            ;( config page-structure )
              ;{
              ;: 0x00 .next             cq -> strucBuffersPage                  ?
              ;: 0x08 .stop             cq -> void                              ?
              ;: 0x10 .here             dq -> strucBuffers                      ?
              ;: 0x18 .last             dq -> strucBuffers                      ?
              ;: 0x20 .full             cw                                      ?
              ;: 0x22 .free             dw                                      ?
              ;: 0x24 .used             dw                                      + ( 0 - size - 2 )
              ;: 0x26 .spam             dw                                      - ( 0 - size - 2 )
              ;: 0x28 .                 db[ page_size - meta_size ]             ?
              ;}
              add                       word  [ .thePage + .offUsed ],          .theContentSize_w
              sub                       word  [ .thePage + .offSpam ],          .theContentSize_w
            add                         .theContentSize,                        2
            ;( config buffer-structure )
              ;{
              ;: 0x00 .size             dw                                      = - size
              ;: 0x02 .                 db[ content_size - 2 ]                  ?
              ;}
              mov                       word  [ .theBuffer + .offSize ],        .theContentSize_w
            neg                         .theContentSize
          ;( get new *buffer )
            mov                         .theInputSize,                           .theContentSize
            mov                         .theInput,                               .theContent
            inc                         .theContentSize
            call                        .new
            jc                          .put.failSafe
        .putB.normal.both:
          push                          .theBuffer
            lea                         rdi,                                    [ .theContent + .theContentSize - 1 ]
            stosb
          pop                           .theBuffer
          ;( load some registers )
            pop                         rsi
            pop                         rdx
          clc                           ;CF                                     False
          or                            .thePage,                               .thePage
                                        ;ZF                                     False
          ret
        .putB.bigfoo:
;:         add                           rsp,                                    ( 2 * 8 )
          jmp                           .failImplementation
    ;( I/O )
    ;{
    ;:  rax                             char                                    char
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
  .putW:
  .putWord:
    ;( I/O )
    ;{
    ;:  rax                             char                                    char
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
    ;< insufficient audited function, use with caution >
    ;( put word char at the end of *buffer )
      call                              .get
      ;( if *buffer is removed -> failRemoved )
        jc                              .failRemoved
      ;( if *buffer is bigfoo -> putW.bigfoo )
        jz                              .putW.bigfoo
      .putW.normal:
        ;( save some registers )
          push                          rdx
          push                          rsi
        ;( if *page_last != *buffer -> putW.normal.inefficient )
          cmp                           qword [ .thePage + .offLast ],          .theBuffer
          jne                           .putW.normal.inefficient
        ;( if free_size < 2 -> putW.normal.inefficient )
          cmp                           word  [ .thePage + .offFree ],          2
          jb                            .putW.normal.inefficient
        .putW.normal.efficient:
          ;( config heap-structure )
            ;{
            ;: 0x00 .list               aq -> strucBuffersPage                  ?
            ;: 0x08 .full               ad                                      ?
            ;: 0x0a .used               ad                                      + 2
            ;: 0x10 .meta               ad                                      ?
            ;: 0x14 .spam               ad                                      ?
            ;: 0x18 .free               ad                                      - 2
            ;: 0x1a .count              ad                                      ?
            ;:      .lastPage           aq -> strucBuffersPage                  *page
            ;:      .last               aq -> strucBuffers                      *buffer
            ;}
            add                         dword [ .used ],                        2
            sub                         dword [ .free ],                        2
            ;mov                         qword [ .lastPage ],                    .thePage
            ;mov                         qword [ .last ],                        .theBuffer
          ;( config page-structure )
            ;{
            ;: 0x00 .next               cq -> strucBuffersPage                  ?
            ;: 0x08 .stop               cq -> void                              ?
            ;: 0x10 .here               dq -> strucBuffers                      + 2
            ;: 0x18 .last               dq -> strucBuffers                      ?
            ;: 0x20 .full               cw                                      ?
            ;: 0x22 .free               dw                                      - 2
            ;: 0x24 .used               dw                                      + 2
            ;: 0x26 .spam               dw                                      ?
            ;: 0x28 .                   db[ page_size - meta_size ]             ?
            ;}
            add                         qword [ .thePage + .offHere ],          2
            sub                         word  [ .thePage + .offFree ],          2
            add                         word  [ .thePage + .offUsed ],          2
          ;( config buffer-structure )
            ;{
            ;: 0x00 .size               dw                                      + 2
            ;: 0x02 .                   db[ content_size - 2 ]                  ?
            ;}
            add                         word  [ .theBuffer + .offSize ],        2
          add                           .theContentSize,                        2
          jmp                           .putW.normal.both
        .putW.normal.inefficient:
          ;( remove old *buffer )
            neg                         .theContentSize
            sub                         .theContentSize,                        2
            ;( config heap-structure )
              ;{
              ;: 0x00 .list             aq -> strucBuffersPage                  ?
              ;: 0x08 .full             ad                                      ?
              ;: 0x0a .used             ad                                      + ( 0 - size - 2 )
              ;: 0x10 .meta             ad                                      ?
              ;: 0x14 .spam             ad                                      - ( 0 - size - 2 )
              ;: 0x18 .free             ad                                      ?
              ;: 0x1a .count            ad                                      - 1
              ;:      .lastPage         aq -> strucBuffersPage                  ?
              ;:      .last             aq -> strucBuffers                      ?
              ;}
              sub                       dword [ .spam ],                        .theContentSize_d
              add                       dword [ .used ],                        .theContentSize_d
              dec                       dword [ .count ]
            ;( config page-structure )
              ;{
              ;: 0x00 .next             cq -> strucBuffersPage                  ?
              ;: 0x08 .stop             cq -> void                              ?
              ;: 0x10 .here             dq -> strucBuffers                      ?
              ;: 0x18 .last             dq -> strucBuffers                      ?
              ;: 0x20 .full             cw                                      ?
              ;: 0x22 .free             dw                                      ?
              ;: 0x24 .used             dw                                      + ( 0 - size - 2 )
              ;: 0x26 .spam             dw                                      - ( 0 - size - 2 )
              ;: 0x28 .                 db[ page_size - meta_size ]             ?
              ;}
              add                       word  [ .thePage + .offUsed ],          .theContentSize_w
              sub                       word  [ .thePage + .offSpam ],          .theContentSize_w
            add                         .theContentSize,                        2
            ;( config buffer-structure )
              ;{
              ;: 0x00 .size             dw                                      = - size
              ;: 0x02 .                 db[ content_size - 2 ]                  ?
              ;}
              mov                       word  [ .theBuffer + .offSize ],        .theContentSize_w
            neg                         .theContentSize
          ;( get new *buffer )
            mov                         .theInputSize,                          .theContentSize
            mov                         .theInput,                              .theContent
            add                         .theContentSize,                        2
            call                        .new
            jc                          .put.failSafe
        .putW.normal.both:
          push                          .theBuffer
            lea                         rdi,                                    [ .theContent + .theContentSize - 2 ]
            stosw
          pop                           .theBuffer
          ;( load some registers )
            pop                         rsi
            pop                         rdx
          clc                           ;CF                                     False
          or                            .thePage,                               .thePage
                                        ;ZF                                     False
          ret
        .putW.bigfoo:
;:         add                           rsp,                                    ( 2 * 8 )
          jmp                           .failImplementation
    ;( I/O )
    ;{
    ;:  rax                             char                                    char
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
  .putD:
  .putDWord:
    ;( I/O )
    ;{
    ;:  rax                             char                                    char
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
    ;< insufficient audited function, use with caution >
    ;( put dword char at the end of *buffer )
      call                              .get
      ;( if *buffer is removed -> failRemoved )
        jc                              .failRemoved
      ;( if *buffer is bigfoo -> putQ.bigfoo )
        jz                              .putD.bigfoo
      .putD.normal:
        ;( save some registers )
          push                          rdx
          push                          rsi
        ;( if *page_last != *buffer -> putD.normal.inefficient )
          cmp                           qword [ .thePage + .offLast ],          .theBuffer
          jne                           .putD.normal.inefficient
        ;( if free_size < 4 -> putD.normal.inefficient )
          cmp                           word  [ .thePage + .offFree ],          4
          jb                            .putD.normal.inefficient
        .putD.normal.efficient:
          ;( config heap-structure )
            ;{
            ;: 0x00 .list               aq -> strucBuffersPage                  ?
            ;: 0x08 .full               ad                                      ?
            ;: 0x0a .used               ad                                      + 4
            ;: 0x10 .meta               ad                                      ?
            ;: 0x14 .spam               ad                                      ?
            ;: 0x18 .free               ad                                      - 4
            ;: 0x1a .count              ad                                      ?
            ;:      .lastPage           aq -> strucBuffersPage                  *page
            ;:      .last               aq -> strucBuffers                      *buffer
            ;}
            add                         dword [ .used ],                        4
            sub                         dword [ .free ],                        4
            ;mov                         qword [ .lastPage ],                    .thePage
            ;mov                         qword [ .last ],                        .theBuffer
          ;( config page-structure )
            ;{
            ;: 0x00 .next               cq -> strucBuffersPage                  ?
            ;: 0x08 .stop               cq -> void                              ?
            ;: 0x10 .here               dq -> strucBuffers                      + 4
            ;: 0x18 .last               dq -> strucBuffers                      ?
            ;: 0x20 .full               cw                                      ?
            ;: 0x22 .free               dw                                      - 4
            ;: 0x24 .used               dw                                      + 4
            ;: 0x26 .spam               dw                                      ?
            ;: 0x28 .                   db[ page_size - meta_size ]             ?
            ;}
            add                         qword [ .thePage + .offHere ],          4
            sub                         word  [ .thePage + .offFree ],          4
            add                         word  [ .thePage + .offUsed ],          4
          ;( config buffer-structure )
            ;{
            ;: 0x00 .size               dw                                      + 4
            ;: 0x02 .                   db[ content_size - 2 ]                  ?
            ;}
            add                         word  [ .theBuffer + .offSize ],        4
          add                           .theContentSize,                        4
          jmp                           .putD.normal.both
        .putD.normal.inefficient:
          ;( remove old *buffer )
            neg                         .theContentSize
            sub                         .theContentSize,                        2
            ;( config heap-structure )
              ;{
              ;: 0x00 .list             aq -> strucBuffersPage                  ?
              ;: 0x08 .full             ad                                      ?
              ;: 0x0a .used             ad                                      + ( 0 - size - 2 )
              ;: 0x10 .meta             ad                                      ?
              ;: 0x14 .spam             ad                                      - ( 0 - size - 2 )
              ;: 0x18 .free             ad                                      ?
              ;: 0x1a .count            ad                                      - 1
              ;:      .lastPage         aq -> strucBuffersPage                  ?
              ;:      .last             aq -> strucBuffers                      ?
              ;}
              sub                       dword [ .spam ],                        .theContentSize_d
              add                       dword [ .used ],                        .theContentSize_d
              dec                       dword [ .count ]
            ;( config page-structure )
              ;{
              ;: 0x00 .next             cq -> strucBuffersPage                  ?
              ;: 0x08 .stop             cq -> void                              ?
              ;: 0x10 .here             dq -> strucBuffers                      ?
              ;: 0x18 .last             dq -> strucBuffers                      ?
              ;: 0x20 .full             cw                                      ?
              ;: 0x22 .free             dw                                      ?
              ;: 0x24 .used             dw                                      + ( 0 - size - 2 )
              ;: 0x26 .spam             dw                                      - ( 0 - size - 2 )
              ;: 0x28 .                 db[ page_size - meta_size ]             ?
              ;}
              add                       word  [ .thePage + .offUsed ],          .theContentSize_w
              sub                       word  [ .thePage + .offSpam ],          .theContentSize_w
            add                         .theContentSize,                        2
            ;( config buffer-structure )
              ;{
              ;: 0x00 .size             dw                                      = - size
              ;: 0x02 .                 db[ content_size - 2 ]                  ?
              ;}
              mov                       word  [ .theBuffer + .offSize ],        .theContentSize_w
            neg                         .theContentSize
          ;( get new *buffer )
            mov                         .theInputSize,                          .theContentSize
            mov                         .theInput,                              .theContent
            add                         .theContentSize,                        4
            call                        .new
            jc                          .put.failSafe
        .putD.normal.both:
          push                          .theBuffer
            lea                         rdi,                                    [ .theContent + .theContentSize - 4 ]
            stosd
          pop                           .theBuffer
          ;( load some registers )
            pop                         rsi
            pop                         rdx
          clc                           ;CF                                     False
          or                            .thePage,                               .thePage
                                        ;ZF                                     False
          ret
        .putD.bigfoo:
;:         add                           rsp,                                    ( 2 * 8 )
          jmp                           .failImplementation
    ;( I/O )
    ;{
    ;:  rax                             char                                    char
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
  .putQ:
  .putQWord:
    ;( I/O )
    ;{
    ;:  rax                             char                                    char
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
    ;< insufficient audited function, use with caution >
    ;( put qword char at the end of *buffer )
      call                              .get
      ;( if *buffer is removed -> failRemoved )
        jc                              .failRemoved
      ;( if *buffer is bigfoo -> putQ.bigfoo )
        jz                              .putQ.bigfoo
      .putQ.normal:
        ;( save some registers )
          push                          rdx
          push                          rsi
        ;( if *page_last != *buffer -> putQ.normal.inefficient )
          cmp                           qword [ .thePage + .offLast ],          .theBuffer
          jne                           .putQ.normal.inefficient
        ;( if free_size < 8 -> putQ.normal.inefficient )
          cmp                           word  [ .thePage + .offFree ],          8
          jb                            .putQ.normal.inefficient
        .putQ.normal.efficient:
          ;( config heap-structure )
            ;{
            ;: 0x00 .list               aq -> strucBuffersPage                  ?
            ;: 0x08 .full               ad                                      ?
            ;: 0x0a .used               ad                                      + 8
            ;: 0x10 .meta               ad                                      ?
            ;: 0x14 .spam               ad                                      ?
            ;: 0x18 .free               ad                                      - 8
            ;: 0x1a .count              ad                                      ?
            ;:      .lastPage           aq -> strucBuffersPage                  *page
            ;:      .last               aq -> strucBuffers                      *buffer
            ;}
            add                         dword [ .used ],                        8
            sub                         dword [ .free ],                        8
            ;mov                         qword [ .lastPage ],                    .thePage
            ;mov                         qword [ .last ],                        .theBuffer
          ;( config page-structure )
            ;{
            ;: 0x00 .next               cq -> strucBuffersPage                  ?
            ;: 0x08 .stop               cq -> void                              ?
            ;: 0x10 .here               dq -> strucBuffers                      + 8
            ;: 0x18 .last               dq -> strucBuffers                      ?
            ;: 0x20 .full               cw                                      ?
            ;: 0x22 .free               dw                                      - 8
            ;: 0x24 .used               dw                                      + 8
            ;: 0x26 .spam               dw                                      ?
            ;: 0x28 .                   db[ page_size - meta_size ]             ?
            ;}
            add                         qword [ .thePage + .offHere ],          8
            sub                         word  [ .thePage + .offFree ],          8
            add                         word  [ .thePage + .offUsed ],          8
          ;( config buffer-structure )
            ;{
             ;: 0x00 .size               dw                                      + 8
            ;: 0x02 .                   db[ content_size - 2 ]                  ?
            ;}
            add                         word  [ .theBuffer + .offSize ],        8
          add                           .theContentSize,                        8
          jmp                           .putQ.normal.both
        .putQ.normal.inefficient:
          ;( remove old *buffer )
            neg                         .theContentSize
            sub                         .theContentSize,                        2
            ;( config heap-structure )
              ;{
              ;: 0x00 .list             aq -> strucBuffersPage                  ?
              ;: 0x08 .full             ad                                      ?
              ;: 0x0a .used             ad                                      + ( 0 - size - 2 )
              ;: 0x10 .meta             ad                                      ?
              ;: 0x14 .spam             ad                                      - ( 0 - size - 2 )
              ;: 0x18 .free             ad                                      ?
              ;: 0x1a .count            ad                                      - 1
              ;:      .lastPage         aq -> strucBuffersPage                  ?
              ;:      .last             aq -> strucBuffers                      ?
              ;}
              sub                       dword [ .spam ],                        .theContentSize_d
              add                       dword [ .used ],                        .theContentSize_d
              dec                       dword [ .count ]
            ;( config page-structure )
              ;{
              ;: 0x00 .next             cq -> strucBuffersPage                  ?
              ;: 0x08 .stop             cq -> void                              ?
              ;: 0x10 .here             dq -> strucBuffers                      ?
              ;: 0x18 .last             dq -> strucBuffers                      ?
              ;: 0x20 .full             cw                                      ?
              ;: 0x22 .free             dw                                      ?
              ;: 0x24 .used             dw                                      + ( 0 - size - 2 )
              ;: 0x26 .spam             dw                                      - ( 0 - size - 2 )
              ;: 0x28 .                 db[ page_size - meta_size ]             ?
              ;}
              add                       word  [ .thePage + .offUsed ],          .theContentSize_w
              sub                       word  [ .thePage + .offSpam ],          .theContentSize_w
            add                         .theContentSize,                        2
            ;( config buffer-structure )
              ;{
              ;: 0x00 .size             dw                                      = - size
              ;: 0x02 .                 db[ content_size - 2 ]                  ?
              ;}
              mov                       word  [ .theBuffer + .offSize ],        .theContentSize_w
            neg                         .theContentSize
          ;( get new *buffer )
            mov                         .theInputSize,                          .theContentSize
            mov                         .theInput,                              .theContent
            add                         .theContentSize,                        8
            call                        .new
            jc                          .put.failSafe
        .putQ.normal.both:
          push                          .theBuffer
            lea                         rdi,                                    [ .theContent + .theContentSize - 8 ]
            stosq
          pop                           .theBuffer
          ;( load some registers )
            pop                         rsi
            pop                         rdx
          clc                           ;CF                                     False
          or                            .thePage,                               .thePage
                                        ;ZF                                     False
          ret
        .putQ.bigfoo:
;:         add                           rsp,                                    ( 2 * 8 )
          jmp                           .failImplementation
    ;( I/O )
    ;{
    ;:  rax                             char                                    char
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 set if bigfoo, clr if normal
    ;}
  .rev:
  .revive:
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 unchanged
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set
    ;:  ZF                              ignored                                 clr
    ;}
    ;< insufficient audited function, use with caution >
    ;( revive *buffer )
      call                              .get
      ;( if *buffer is not removed -> failDone )
        jnc                             .failDone
      push                              rax
        movzx                           rax,                                    word  [ .theBuffer + .offSize ]
        neg                             rax                                     ;rax = size
        add                             rax,                                    2
        ;( config heap-structure )
          ;{
          ;: 0x00 .list                 aq -> strucBuffersPage                  ?
          ;: 0x08 .full                 ad                                      ?
          ;: 0x0a .used                 ad                                      + size + 2
          ;: 0x10 .meta                 ad                                      ?
          ;: 0x14 .spam                 ad                                      - size - 2
          ;: 0x18 .free                 ad                                      ?
          ;: 0x1a .count                ad                                      + 1
          ;:      .lastPage             aq -> strucBuffersPage                  *page
          ;:      .last                 aq -> strucBuffers                      *buffer
          ;}
          add                           dword [ .used ],                        eax
          sub                           dword [ .spam ],                        eax
          inc                           dword [ .count ]
          mov                           qword [ .lastPage ],                    .thePage
          mov                           qword [ .last ],                        .theBuffer
        ;( config page-structure )
          ;{
          ;: 0x00 .next                 cq -> strucBuffersPage                  ?
          ;: 0x08 .stop                 cq -> void                              ?
          ;: 0x10 .here                 dq -> strucBuffers                      ?
          ;: 0x18 .last                 dq -> strucBuffers                      ?
          ;: 0x20 .full                 cw                                      ?
          ;: 0x22 .free                 dw                                      ?
          ;: 0x24 .used                 dw                                      + size + 2
          ;: 0x26 .spam                 dw                                      - size - 2
          ;: 0x28 .                     db[ page_size - meta_size ]             ?
          ;}
          add                           word  [ .thePage + .offUsed ],          ax
          sub                           word  [ .thePage + .offSpam ],          ax
        ;( config buffer-structure )
          ;{
          ;: 0x00 .size                 dw                                      size
          ;: 0x02 .                     db[ content_size - 2 ]                  ?
          ;}
          sub                           rax,                                    2
          mov                           word  [ .theBuffer + .offSize ],        ax
      pop                               rax
    ret
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 unchanged
    ;:  rbx                             ignored                                 *content
    ;:  rcx                             ignored                                 content_size
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set
    ;:  ZF                              ignored                                 clr
    ;}
  .store:
    ;( I/O )
    ;{
    ;:  rax                             *address                                *address
    ;:  rbx                             ignored                                 unchanged
    ;:  rcx                             ignored                                 unchanged
    ;:  rdx                             ignored                                 unchanged
    ;:  rsi                             ignored                                 unchanged
    ;:  rdi                             *buffer                                 invalid *buffer
    ;:  r15                             ignored                                 *page
    ;:  CF                              ignored                                 set if failed
    ;:  ZF                              ignored                                 undefined
    ;}
    push                                rbx
    push                                rcx
    push                                r15
      push                              .theBuffer                                                                      ;-> new *buffer
      push                              .theAddress                                                                     ;-> *var
        mov                             .theAddress,                            qword [ .theAddress ]                   ;-> old *buffer
;       add                             rsp,                                    ( 5 * 8 )
;       ret
;       mov                             qword [ echoIt ],                       .theBuffer
;       echo_n
;       echo_hexValue                   echoIt,                                 8
;       echo_n
;       add                             rsp,                                    ( 5 * 8 )
;       ret
        ;( if old *buffer = NULL -> store.it )
          or                            .theAddress,                            .theAddress
          jz                            .store.it
        ;( else if old *buffer = new *buffer -> store.it )
          cmp                           .theBuffer,                             .theAddress
          je                            .store.it
        ;( else: delete old buffer and -> store.it )
          mov                           .theBuffer,                             .theAddress
          call                          buffers.delete
        .store.it:
      pop                               rdi                                                                             ;-> *var
      pop                               rax                                                                             ;-> new *buffer
      stosq                                                                                                             ;mov qword [ *var ], ( new *buffer )
    pop                                 r15
    pop                                 rcx
    pop                                 rbx
    ret
  .utf8:
    ;( I/O )
    ;{
    ;:  rax                             ignored                                 char
    ;:  rbx                             ignored                                 *char
    ;:  rcx                             ignored                                 unchanged
    ;:  rdx                             ignored                                 char.size
    ;:  rsi                             *string                                 *string + char.size
    ;:  rdi                             ignored                                 unchanged
    ;:  r8                              ignored                                 changed, if char.size > 2
    ;:  r11                             ignored                                 changed, if char.size > 3
    ;:  r15                             ignored                                 unchanged
    ;:  CF                              ignored                                 set if failed
    ;}
    movzx                               rax,                                    byte [ rsi ]
    ;( if ascii )
      cmp                               rax,                                    0x80
      mov                               rdx,                                    1
      jae                               @f
    ;{
      .utf8.return:
      mov                               rbx,                                    rsi
      clc
      add                               rsi,                                    rdx
      ret
    ;}
    ;( else if invalid -> failChar )
      @@:
      mov                               rbx,                                    rax
      cmp                               rax,                                    0xc0
      jb                                .failChar
    ;( else if 2-bytes )
      @@:
      cmp                               rax,                                    0xe0
      jae                               @f
    ;{
      and                               rbx,                                    0x1f
      movzx                             rax,                                    byte [ rsi + 1 ]
      shl                               rbx,                                    6
      and                               rax,                                    0x3f
      mov                               rdx,                                    2
      or                                rax,                                    rbx
      jmp                               .utf8.return
    ;}
    ;( else if 3-bytes )
      @@:
      cmp                               rax,                                    0xf0
      jae                               @f
    ;{
      movzx                             rax,                                    byte [ rsi + 2 ]
      and                               rbx,                                    0x0f
      movzx                             r8,                                     byte [ rsi + 1 ]
      and                               rax,                                    0x3f
      shl                               rbx,                                    12
      shl                               rax,                                    6
      and                               r8,                                     0x3f
      or                                rax,                                    r8
      mov                               rdx,                                    3
      or                                rax,                                    rbx
      jmp                               .utf8.return
    ;}
    ;( else if 4-bytes )
      @@:
      movzx                             r8,                                     byte [ rsi + 1 ]
      cmp                               rax,                                    0xf8
      jae                               .failChar
    ;{
      movzx                             r11,                                    byte [ rsi + 2 ]
      and                               rbx,                                    0x07
      movzx                             rax,                                    byte [ rsi + 3 ]
      and                               r8,                                     0x3f
      and                               rax,                                    0x3f
      shl                               r8,                                     6
      shl                               rax,                                    12
      and                               r11,                                    0x3f
      or                                rax,                                    r8
      shl                               rbx,                                    18
      or                                rax,                                    r11
      mov                               rdx,                                    4
      or                                rax,                                    rbx
      jmp                               .utf8.return
    ;}
  .wastepicker:
    ;( thread, cleans up memory )
      @@:
        onDebug
        {
          echo_put                      .msgWastepicker
        }
        nanosleep                       2
      jmp                               @b
onAlone
{
  .failInternal:
  .failRemoved:
  ;.failInit:
  .failBoundaries:
  .failSize:
  .failInput:
  .failDone:
  .failChar:
  .failImplementation:
  .failNull:
  .failInvalid:
  .failReturn:
    ;( set return-values to invalid values and return )
      xor                               .thePage,                               .thePage
      stc                               ;ERROR!
  .failSafe:
      ret
}
onDebug
{
  .failInternal:
    mov                                 sys2arg,                                .msgFailInternal.size
    lea                                 sys1arg,                                [ .msgFailInternal ]
    jmp                                 .failReturn
  .failRemoved:
    jz                                  .failSafe
    mov                                 sys2arg,                                .msgFailRemoved.size
    lea                                 sys1arg,                                [ .msgFailRemoved ]
    jmp                                 .failReturn
  ;.failInit:
  ;: mov                                 sys2arg,                                .msgFailInit.size
  ;: lea                                 sys1arg,                                [ .msgFailInit ]
  ;: jmp                                 .failReturn
  .failBoundaries:
    mov                                 sys2arg,                                .msgFailBoundaries.size
    lea                                 sys1arg,                                [ .msgFailBoundaries ]
    jmp                                 .failReturn
;: .failSize:
;:   mov                                 sys2arg,                                .msgFailSize.size
;:   lea                                 sys1arg,                                [ .msgFailSize ]
;:   jmp                                 .failReturn
;: .failInput:
;:   mov                                 sys2arg,                                .msgFailInput.size
;:   lea                                 sys1arg,                                [ .msgFailInput ]
;:   jmp                                 .failReturn
  .failDone:
    mov                                 sys2arg,                                .msgFailDone.size
    lea                                 sys1arg,                                [ .msgFailDone ]
    jmp                                 .failReturn
  .failChar:
    mov                                 sys2arg,                                .msgFailChar.size
    lea                                 sys1arg,                                [ .msgFailChar ]
    jmp                                 .failReturn
  .failImplementation:
    mov                                 sys2arg,                                .msgFailImplementation.size
    lea                                 sys1arg,                                [ .msgFailImplementation ]
    jmp                                 .failReturn
  .failNull:
    mov                                 sys2arg,                                .msgFailNull.size
    lea                                 sys1arg,                                [ .msgFailNull ]
    jmp                                 .failReturn
  .failInvalidFree:
    mov                                 sys2arg,                                .msgFailInvalidFree.size
    lea                                 sys1arg,                                [ .msgFailInvalidFree ]
    jmp                                 .failReturn
  .failInvalid:
    mov                                 sys2arg,                                .msgFailInvalid.size
    lea                                 sys1arg,                                [ .msgFailInvalid ]
  .failReturn:
    ;( put error-message, set return-values to invalid values and return )
      mov                               sys0arg,                                STDOUT
      sys_call                          sys_write
      xor                               .thePage,                               .thePage
  .fail:
      stc                               ;ERROR!
  .failSafe:
      ret
}
;:     ;( if *page != NULL -> new.look )
;:       or                              .thePage,                               .thePage
;:       jnz                             .new.look
;:     .new.init:
;:       push                            rax
;:       push                            .theInputSize
;:       push                            .theInput
;:       push                            .theContentSize
;:         xor                           sys5arg,                                sys5arg
;:         mov                           sys4arg,                                ( 0 - 1 )
;:         mov                           sys3arg,                                0x0000000000000022  ;anonymous, private
;:         mov                           sys2arg,                                0x0000000000000003  ;read, write
;:         mov                           sys1arg,                                ( 4096 * .ctrPage )
;:         sys_call                      sys_mmap
;:         ;( *buffer <= sys0ret )
;:           mov                         .theBuffer,                             sys0ret
;:       pop                             .theContentSize
;:       pop                             .theInput
;:       pop                             .theInputSize
;:       pop                             rax
;:       ;( if *buffer = ERRNO -> failInit )
;:         or                            .theBuffer,                             .theBuffer
;:         js                            .failInternal
;:       mov                             .thePage,                               .theBuffer
;:       ;( config heap-structure )
;:         ;{
;:         ;: 0x00 .list                 aq -> strucBuffersPage                  *page
;:         ;: 0x08 .full                 ad                                      lenFull
;:         ;: 0x0a .used                 ad                                      0x00000000
;:         ;: 0x10 .meta                 ad                                      lenMeta
;:         ;: 0x14 .spam                 ad                                      0x00000000
;:         ;: 0x18 .free                 ad                                      lenFree
;:         ;: 0x1a .count                ad                                      0x00000000
;:         ;:      .lastPage             aq -> strucBuffersPage                  ?
;:         ;:      .last                 aq -> strucBuffers                      ?
;:         ;}
;:         mov                           qword [ .list ],                        .thePage
;:         mov                           qword [ .full ],                        .lenFull
;:         mov                           qword [ .meta ],                        .lenMeta
;:         mov                           qword [ .free ],                        .lenFree
;:       ;( config page-structure  )
;:         ;{
;:         ;: 0x00 .next                 cq -> strucBuffersPage                  0x0000000000000000
;:         ;: 0x08 .stop                 cq -> void                              *page + lenFull
;:         ;: 0x10 .here                 dq -> strucBuffers                      *page + lenMeta
;:         ;: 0x18 .last                 dq -> strucBuffers                      ?
;:         ;: 0x20 .full                 cw                                      lenFull
;:         ;: 0x22 .free                 dw                                      lenFree
;:         ;: 0x24 .used                 dw                                      0x0000
;:         ;: 0x26 .spam                 dw                                      0x0000
;:         ;: 0x28 .                     db[ page_size - meta_size ]             ?
;:         ;}
;:         mov                           qword [ .thePage + .offNext ],          0x0000000000000000
;:         add                           .theBuffer,                             .lenFull
;:         mov                           qword [ .thePage + .offStop ],          .theBuffer
;:         sub                           .theBuffer,                             .lenFree
;:         mov                           qword [ .thePage + .offHere ],          .theBuffer
;:         mov                           qword [ .thePage + .offFree ],          (( .lenFull ) + ( 0x10000 * .lenFree ))
